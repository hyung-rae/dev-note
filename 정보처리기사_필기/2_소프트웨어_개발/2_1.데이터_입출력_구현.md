- [자료구조](#자료구조)
- [트리 tree](#트리-tree)
- [정렬 sort](#정렬-sort)
- [검색 - 이분 검색 / 해싱](#검색---이분-검색--해싱)
- [데이터베이스 개요](#데이터베이스-개요)
- [절차형 SQL](#절차형-sql)


### 자료구조

1. 자료 구조의 분류
    1. 선형구조
        
        **`배열` `선형 리스트` `스택` `큐` `데크`**
        
    2. 비선형 구조
        
        **`트리` `그래프`**
        
2. 연결 리스트
    - 노드의 삽입•삭제 작업이 용이하다.
    - 연결을 위한 링크(포인터) 부분이 필요하다.
    - 연결을 위한 포인터를 찾는 시간이 필요 → 접근 속도가 느리다.
    - 중간 노드 연결이 끊어지면 . 그다음 노드를 찾기 힘들다.
3. **`스택 Stack`**
    1. 스택의 응용 분야
        - 함수 호출의 순서 제어
        - 인터럽트의 처리
        - 수식 계산 및 수식 표기법
        - 컴파일러를 이용한 언어 번역
        - 부 프로그램 호출 시 복귀 주소 저장
        - 서브루틴 호출 및 복귀 주소 저장
    2. 스택의  push 삽입 과 pop 삭제
        - push 자료 입력 , pop 자료 출력 명령
4. **`큐 Que`**
    - 리스트의 한쪽에서는 삽입 작업이 이루어지고 다른 한쪽에서는 삭제 작업이 이루어지도록 구성한 자료 구조
    - FIFO 선입선출 방식
5. **`데크 Deque`**
    - 삽입과 삭제가 리스트의 양쪽 끝에서 모두 발생
    - 입력이 한쪽에서만 발생, 출력은 양쪽에서 일어날 수 있는 **`입력 제한`**
    - 입력은 양쪽에서 일어나고 출력은 한곳에서만 이루어지는 **`출력 제한`**
6. 방향 / 무방향 그래프의 최대 간선수
    - n 개의 정점으로 구성된 **`무방향` 최대 간선수 → n(n-1)/2**
    - **`방향 그래프`에서 최대 간선수 → n(n-1)**
7. 인접행렬을 이용한 그래프 표현 방법
    - 방향 그래프에서 V[i] V[j] 관계를 나타내는 행렬의 원소를 P[i][j] 라 할때, → 방향 간선이 있으면 P[i][j] = 1 , 없으면 0
    - 무방향 그래프에서 V[i] 와 V[j] 가 서로 인접하면 P[i][j] = 1 , 인접하지 않으면 0

### 트리 tree

1. 트리의 개요
    - 트리는 정점(node)과 선분(branch)을 이용하여 사이클을 이루지 않도록 구성한 그래프의 특수한 형태
    - **`디그리 (차수)`** **→ 각 노드에서 뻗어나온 가지의 수**
    - **`단말 노드 (Terminal Node)` → 자식이 하나도 없는 노드 === 디그리가 0**
2. 운행법
    - Preorder (전위)
        
        **`RootNode` → `Left` → `Right`**
        
    - Inorder (중위)
        
        **`Left` → `RootNode` → `Right`**
        
    - Postorder (후위)
        
        **`Left` → `Right` → `RootNode`**
        
3. 수식의 표기법
    - PreFix 전위 표기법
        - 연산자가 Data 앞에
        - **`중위`** (A+B)*(C+D) → **`전위`** *+AB+CD
    - InFix 중위 표기법
        - 데이터 중간에 연산자 표시
        - **`중위` → `전위` || `후위` → `data` `data` `연산자` 일경우 연산자를 전위 , 후위에 맞게 이동**
    - PostFix 후위 표기법
        - 연산자가 Data 뒤에
        - **`중위`** (A+B)*(C+D) → **`후위`** AB+CD+*

### 정렬 sort

1. 삽입 정렬
    - [8, 5, 6, 2, 4]
        
        1회전 → [5, 8, 6, 2, 4]
        
        2회전 → [5, 6, 8, 2, 4]
        
        3회전 → [2, 5, 6, 8, 4]
        
        4회전 → [2, 4, 5, 6, 8]
        
2. 선택 정렬
    - [8, 5, 6, 2, 4]
        
        1회전 → [2, 5, 6, 8, 4]
        
        2회전 → [2, 4, 6, 8, 5]
        
        3회전 → [2, 4, 5, 8, 6]
        
        4회전 → [2, 4, 5, 6, 8]
        
3. 버블 정렬
    - [8, 5, 6, 2, 4]
        
        1회전 → [5, 6, 2, 4, 8]
        
        2회전 → [5, 2, 4, 6, 8]
        
        3회전 → [2, 4, 5, 6, 8]
        
4. 퀵 정렬
    - 레코드의 많은 자료 이동을 없애고 하나의 파일을 부분적으로 나누어 가면서 정렬
    - 분할과 정복을 통해 자료를 정렬
    - 피봇을 사용하며, 최악의 경우 n(n-1)/2 회의 비교를 수행한다.
5. 힙 정렬
    - 전이진 트리를 이용한 정렬
    - 평균 시간 복잡도 n log2n , 최악 n^2

### 검색 - 이분 검색 / 해싱

1. 이분 검색 (이진 검색)
    - 반드시 순서화(정렬)된 파일이어야 검색할 수 있다.
    - 비교 횟수를 거듭할 때마다 검색 대상이 되는 데이터의 수가 절반으로 줄어든다.
    - 탐색 효율이 좋고 탐색 시간이 적게 소요된다.
    - 중간 레코드 번호 M → **`첫 번째 레코드 번호 + 마지막 레코드 번호 / 2`**
2. 주요 해싱 함수
    - 제산법 → 레코드 키를 해시표의 크기보다 큰 수 중에서 가장 작은 소수로 나눈 나머지를 홈 주소로 삼는 방식
    - 제곱법 → 레코드 키 값을 제곱한 후 그 중간 부분의 값을 홈 주소로 삼는 방식
    - 폴딩법 → 레코드 키 값을 여러 부분으로 나눈 후 각 부부의 값을 더하거나 XOR(배타적 논리합)한 값을 홈 주소로 삼는 방식
    - 숫자 분석법 → 키 값을 이루는 숫자의 분포를 분석하여 비교적 고른 자리를 필요한 만큼 택해서 홈 주소로 삼는 방식
3. 체이닝
    - Collision이 발생하면 버킷에 할당된 연결 리스트에 데이터를 저장하여 문제를 해결하는 방법

### 데이터베이스 개요

1. DBMS의 필수 기능
    - 정의 기능
        - 모든 응용 프로그램들이 요구하는 데이터 구조를 지원하기 위해 데이터베이스에 저장될 데이터의 형 type 과 구조에 대한 정의, 이용 방식, 제약 조건 등을 명시하는 기능
    - 조작 기능
        - 데이터 검색, 갱신, 삽입, 삭제 등을 체계적으로 처리하기 위해 사용자와 데이터베이스 사이의 인터페이스 수단을 제공하는 기능
    - 제어 기능
        - 데이터베이스를 접근하는 갱신, 삽입, 삭제 작업이 정확하게 수행되어 데이터의 무결성이 유지되도록 제어하는 기능
2. 스키마 3계층
    - 외부 스키마
        - 사용자나 응용 프로그래머가 각 개인의 입장에서 필요로 하는 데이터베이스의 논리적 구조를 정의한 것
    - 개념 스키마
        - 데이터베이스의 전체적인 논리적 구조로, 개체 간의 관계와 제약 조건을 나타내고, 접근 권한, 보안 및 무결성 규칙에 관한 명세를 정의
    - 내부 스키마
        - 물리적 저장장치의 입장에서 본 데이터베이스 구조로서, 실제로 데이터베이스에 저장될 레코드의 형식을 정의하고 저장 데이터 항목의 표현 방법, 내부 레코드의 물리적 순서 등을 나타냄

### 절차형 SQL

- 테스트와 디버깅의 목적
    
    테스트를 통해 오류를 발견한 후 디버깅을 통해 오류가 발생한 소스 코드를 추적하며 수정한다.