- [소프트웨어 아키텍처](#소프트웨어-아키텍처)
- [아키텍처 패턴](#아키텍처-패턴)
- [객체지향](#객체지향)
- [객체지향 분석 및 설계](#객체지향-분석-및-설계)
- [모듈](#모듈)
- [공통 모듈](#공통-모듈)
- [코드](#코드)
- [디자인 패턴](#디자인-패턴)

### 소프트웨어 아키텍처

1. 상위 설계와 하위 설계

   |           | 상위 설계                | 하위 설계                     |
   | --------- | ------------------------ | ----------------------------- |
   | 별칭      | 아케텍처 설계, 예비 설계 | 모듈 설계, 상세 설계          |
   | 설계 대상 | 시스템의 전체적인 구조   | 시스템의 내부구조 및 행위     |
   | 세부 목록 | 구조, DB, 인터페이스     | 컴포넌트, 자료 구조, 알고리즘 |

2. 모듈화
   1. 소프트웨어의 성능을 향상 + 시스템의 수정 및 재사용, 유지 관리 용이하도록 기능들을 모듈 단위로 나누는것
   2. 기능의 분리가 가능 → 인터페이스가 단순해진다.
   3. 프로그램의 효율적인 관리 가능, 오류 파급 효과를 최소화할 수 있다.
   4. 너무 작게 나누면 개수가 많아져 모듈간의 통합 비용이 많이 든다.
   5. 너무 크게 나누면 개수가 적어 통합 비용은 적게 들지만 모듈 하나의 개발 비용이 많이 든다.
3. 추상화의 유형
   1. 과정 추상화
   2. 데이터(자료) 추상화
   3. 제어 추상화
4. 정보 은닉
   1. 모듈 내부에 포함된 절차와 자료들의 정보가 감추어져 다른 모듈이 접근하거나 변경하지 못하도록 하는 기법
   2. 정보 은닉된 모듈끼리 커뮤니케이션할 필요가 있을 때는 필요한 정보만 인터페이스를 통해 주고 받는다.
   3. 정보은닉을 통해 모듈을 독립적으로 수행할 수 있고, 하나의 모듈이 변경되더라도 다른 모듈에 영향 x
5. 소프트웨어 아키텍처의 설계 과정

   **`설계 목표설정` → `시스템 타입 결정` → `아키텍처 패턴 적용` → `서브시스템 구체화` → `검토`**

### 아키텍처 패턴

**`파이프 필터 패턴`**

- 데이터 스트림 절차의 각 단계를 필터 컴포넌트로 캡슐화하여 파이프를 통해 데이터를 전송하는 패턴
- 필터 간 데이터 이동 시 데이터 변환으로 인한 **`오버헤드가 발생한다.`**

**`MVC 패턴`**

- 모델 → 서브시스템의 핵심 기능과 데이터를 보관함
- 뷰 → 사용자에게 정보를 표시함
- 컨트롤러 → 사용자로부터 입력된 변경 요청을 처리하기 위해 모델에게 명령을 보냄

**`마스터 슬레이브 패턴`**

- 동일한 구조의 슬레이브 컴포넌트로 작업 분할 → 슬레이브 컴포넌트에서 처리된 결과물을 다시 돌려받는 방식
- 마스터 컴포넌트는 모든 작업의 주체, 슬레이브 컴포넌트는 마스터 컴포넌트의 지시에 따라 작업 수행 후 결과 반환
- **`장애 허용 시스템` `병렬 컴퓨팅 시스템`** 주로 활용

### 객체지향

**`객체 Object`**

- 데이터와 데이터를 처리하는 함수를 묶어 놓은 하나의 소프트웨어 모듈

**`메시지`**

- 객체들 간에 상호작용을 하는 데 사용되는 수단
- 객체에게 어떤 행위를 하도록 지시하는 명령 또는 요구사항

**`클래스 Class`**

- 공통된 속성과 행위를 갖는 객체의 집합
- 개체의 일반적인 타입을 의미한다.
- 클래스에 속한 각각의 객체를 인스턴스라 한다.

**`캡슐화`**

- 데이터와 데이터를 처리하는 함수를 하나로 묶는 것을 의미
- 캡슐화된 객체 → 외부 모듈의 변경으로 인한 파급 효과가 적다
- 캡슐화를 수행하면 인터페이스가 단순화된다.
- 캡슐화된 객체들은 재사용이 용이하다.

**`상속`**

- 상위 클래스의 모든 속성과 연산을 하위 클래스가 물려받는 것

**`다형성`**

- 오버로딩 → 상위 클래스 메소드와 이름은 같지만 인수를 받는 자료형과 개수를 달리하여 여러 기능을 정의 (확장)
- 오버라이딩 →상위 클래스 메소드와 이름은 같지만 메소드 안의 로직은 자식 클래스에서 재정의해서 사용 (재정의)

**`집단화`**

- 클래스들 사이의 **`부분-전체`** 관계 또는 **`부분`** 의 관계로 설명되는 연관성의 한 종류
- 관련 있는 객체들을 묶어 하나의 상위 객체를 구성하는 것

### 객체지향 분석 및 설계

1. 객체지향 분석 방법론 **`Coad 와 Yourdon 방법`**
   - E-R 다이어그램을 사용 객체의 행위를 모델링
   - 객체 식별, 구조 식별, 주제 정의, 속성과 인스턴스 연결 정의, 연산과 메시지 연결 정의 등의 과정으로 구성하는 기법
2. 럼바우의 분석 기법

   **`객체 모델링`** == 정보 모델링

   - 시스템에서 요구되는 객체를 찾아 속성과 연산 식별 및 객체들 간의 관계를 규정하여 **`객체 다이어그램으로 표시`**

   **`동적 모델링`**

   - **`상태 다이어그램(상태도 이용)`** → 시간의 흐름에 따른 객체들 간의 제어 흐름, 상호작용, 동작 순서 등의 동적인 행위를 표현

   **`기능 모델링`**

   - **`자료 흐름도 DFD`** → 다수의 프로세스들 간의 자료 흐름을 중심으로 처리 과정을 표현 \*\*\*\*

3. 객체지향 설계 원칙 **`SOLID 원칙`**

   **`단일 책임 원칙 SRP`**

   - 객체는 단 하나의 책임만 가져야 한다.
   - **응집도는 높고, 결합도는 낮게**

   **`개방 폐쇄 원칙 OCP`**

   - 기존의 코드를 변경하지 않고 기능을 추가할 수 있도록 해야한다.
   - 대표적인 방법 → 공통 인터페이스를 하나의 인터페이스로 묶어 캡슐화하는 방법

   **`리스코프 치환 원칙 LSP`**

   - 자식 클래스는 최소한 부모 클래스에서 가능한 행위는 수행해야 한다.
   - 자식 클래스는 부모 클래스를 재정의 하지 않고 확장만 가능하다.

   **`인터페이스 분리 원칙 ISP`**

   - 자신이 사용하지 않는 인터페이스와 의존 관계를 맺거나 영향을 받아서는 x
   - 인터페이스가 갖는 하나의 책임

   **`의존 역전 원칙 DIP`**

   - 각 객체들 간의 의존 관계가 성립될 때 → 추상성이 낮은 클래스보다 추상성이 높은 클래스와 의존 관계를 맺어야 한다.
   - 일반적으로 인터페이스를 활용하면 이 원칙은 준수됨

### 모듈

1. 모듈의 개요
   - 모듈화를 통해 분리된 시스템의 각 기능 → 서브루틴, 서브시스템, 소프트웨어 내의 프로그램, 작업 단위 등
   - 모듈은 단독으로 컴파일 가능, 재사용 할 수 있다.
   - 모듈은 다른 모듈에서의 접근이 가능하다.
2. 결합도의 종류 (결합도의 정도 약함 → 강함 순서)

   **`자료 결합도`**

   → 모듈 간의 인터페이스가 자료 요소로만 구성될 때의 결합도

   **`스탬프 결합도`**

   → 모듈 간의 인터페이스로 배열이나 레코드 등의 자료 구조가 전달될 때의 결합도

   **`제어 결합도`**

   → 어떤 모듈이 다른 모듈 내부의 논리적인 흐름을 제어하기 위해 신호를 이용하여 통신하거나 제어 요소를 전달하는 결합도

   **`외부 결합도`**

   → 어떤 모듈에서 선언한 데이터(변수)를 외부의 다른 모듈에서 참조할 때의 결합도

   **`공통 결합도`**

   → 공유되는 공통 데이터 영역을 여러 모듈이 사용할 때의 결합도

   **`내용 결합도`**

   → 한 모듈이 다른 모듈의 내부 기능 및 그 내부 자료를 직접 참조하거나 수정할 때의 결합도

3. 응집도
   - 명령어나 호출문 등 모듈의 내부 요소들의 서로 관련되어 있는 정도
   - 모듈이 독립적인 기능으로 정의되어 있는 정도
4. 응집도의 종류 (응집도의 정도 약함 → 강함 순서)

   **`우연적 응집도`**

   → 모듈 내부의 각 구성 요소들이 서로 관련 없는 요소로만 구성

   **`논리적 응집도`**

   → 유사한 성격을 갖거나 특정 형태로 분류되는 처리 요소들로 구성

   **`시간적 응집도`**

   → 특정 시간에 처리되는 몇 개의 기능을 모아 하나의 모듈로 작성할 경우

   **`절차적 응집도`**

   → 모듈이 다수의 관련 기능을 가질때 모듈 안의 구성 요소들이 그 기능을 순차적으로 수행할 경우

   **`교환적 응집도`**

   → 동일한 입•출력을 사용하여 서로 다른 기능을 수행하는 구성요소들로 구성

   **`순차적 응집도`**

   → 모듈 내 하나의 활동으로부터 나온 출력 데이터를 그 다음 활동의 입력 데이터로 사용할 경우

   **`기능적 응집도`**

   → 모듈 내부의 모든 기능 요소들이 단일 문제와 연관되어 수행될 경우

5. **`팬인 팬아웃`**
   - 팬인 → 어떤 모듈을 제어(호출) 하는 모듈의 수
   - 팬아웃 → 어떤 모듈에 의해 제어(호출되는 모듈의 수)
6. N-S 차트 (== 박스 다이어그램 , Chapin Chart)
   - 논리의 기술에 중점을 둔 도형을 이용한 표현 방법
   - 연속, 선택 . 및다중 선택, 반복 등의 제어 논리 구조를 표현
   - **`GOTO 나 화살표를 사용하지 X`**
   - 조건이 복합되어 있는 곳의 처리를 시각적으로 명확히 식별하는데 적합
   - 이해하기 쉽고, 코드 변환이 용이

### 공통 모듈

1. 명확성
   - 중의적으로 해석되지 않도록 명확하게 작성
2. 재사용
   - 개발된 기능이 새로운 시스템이나 기능 개발에 사용할 수있는 정도
   - 재사용 규모에 따른 분류 → 함수와 객체, 컴포넌트, 애플리케이션
3. 컴포넌트
   - 독립적인 업무 또는 기능을 수행하는 실행 코드 기반으로 작성된 모듈
   - 컴포넌트 자체에 대한 수정 없이 인터페이스를 통해 통신하는 방식으로 재사용
4. 효과적인 모듈 설계 방안
   - **`결합도는 줄이고 응집도는 높여`** 모듈의 독립성과 재사용성을 높인다.
   - 모듈의 제어 영역 안에서 그 모듈의 영향 여역을 유지 시킨다.
   - 복잡도와 중복성을 줄이고 일관성을 유지
   - 모듈의 기능은 예측 가능 + 지나치게 제한적이지 않게한다.
   - 유지보수가 용이해야한다.

### 코드

1. 순차 코드
   - 자료의 발생 순서, 크기 순서 등 일정 기준에 따라서 차례로 일련번호를 부여
   - 순서코드 또는일련번호 코드라고도 한다.
2. 표의 숫자 코드
   - 코드화 대상 항목의 성질, 길이, 넓이, 부피, 지름, 높이 등 물리적 수치를 코드에 적용
   - 유효 숫자 코드라고도 한다.

### 디자인 패턴

1. 디자인 패턴
   - 각 모듈의 세분화된 역할이나 모듈들 간의 인터페이스와 같은 코드를 작성하는 수준의 세부적인 구현 방안을 설계할때 참조하는 전형적인 해결 방식 or 예제를 의미
   - **`생성 패턴`** **`구조 패턴`** **`행위 패턴`**
2. 디자인 패턴 사용의 장•단점
   - 범용적인 코딩 스타일로 인해 구조 파악이 용이하다.
   - 객체지향 설계 및 구현의 생산성을 높이는 데 적합
   - 검증된 구조의 재사용을 통해 개발 시간, 비용 절약
   - 초기 투자 비용이 부담될 수 있다.
   - 개발자 간의 원할한 의사소통이 가능
3. 생성 패턴

   **`추상 팩토리`**

   → 구체적인 클래스에 의존 x, 인터페이스를 통해 서로 연관•의존하는 객체들의 그룹으로 생성하여 추상적으로 표현

   **`빌더`**

   → 작게 분리된 인스턴스를 건축 하듯이 조합하여 객체를 생성함

   **`팩토리 메소드`**

   → 객체 생성을 서브 클래스에서 처리하도록 분리하여 캡슐화한 패턴

   → 상위클래스에서 인터페이스만 정의하고 실제 생성은 서브 클래스가 담당함

   → 가상 생성자 패턴이라고도 함

   **`프로토타입`**

   → 원본 객체를 복제하는 방법으로 객체를 생성하는 패턴

   **`싱글톤`**

   → 하나의 객체를 생성하면 생성된 객체를 어디서든 참조할 수 있지만, 여러 프로세스가 동시에 참조할 수는 없음

4. 구조 패턴

   **`어탭터`**

   → 호환성이 없는 클래스들의 인터페이스를 다른 클래스가 이용할 수 있도록 변환해주는 패턴

   **`브리지`**

   → 구현부에서 추상층을 분리하여, 서로가 독립적으로 확장할 수 있도록 구성한 패턴

   **`컴포지트`**

   → 여러 객체를 가진 복합 객체와 단일 객체를 구분 없이 다루고자 할 때 사용하는 패턴

   **`데코레이터`**

   → 객체 간의 결합을 통해 능동적으로 기능들을 확장할 수 있는 패턴

   → 임의의 객체에 부가적인 기능을 축하기 위해 다른 개체들을 덧붙이는 방식으로 구현함

   **`퍼싸드`**

   → 복잡한 서브 클래스들을 피해 더 상위에 인터페이스를 구성함으로써 서브 클래스들의 기능을 간편하게 사용할 수있도록 하는 패턴

   **`플라이웨이트`**

   → 인스턴스가 필요할 때마다 매번 생성하는 것이 아니고 가능한 공유해서 사용해 메모리를 절약하는 패턴

   **`프록시`**

   → 접근이 어려운 객체와 여기에 연결하려는 객체 사이에서 인터페이스 역할을 수행하는 패턴

5. 행위 패턴

   **`책임 연쇄`**

   → 요청을 처리할 수 있는 객체가 둘 이상 존재, 한 객체가 처리하지 못하면 다음 객체로 넘어가는 패턴

   **`커맨드`**

   → 요청을 객체의 형태로 캡슐화하여 재이용하거나 취소할 수 있도록 요청에 필요한 정보를 저장, 로그에 남기는 패턴

   **`인터프리터`**

   → 언어에 문법 표현을 정의하는 패턴

   → SQL 이나 프로토콜과 같은 것을 개발할때 사용함

   **`반복자`**

   → 자료 구조와 같이 접근이 잦은 객체에 대해 동일한 인터페이스를 사용하도록 하는 패턴

   **`중재자`**

   → 수많은 객체들 간의 복잡한 상호작용을 캡슐화하여 객체로 정의하는 패턴

   **`메멘토`**

   → 특정 시점에서의 객체 내부 상태를 객체화함으로써 이후 요청에 따라 객체를 해당 시점의 상태로 돌릴 . 수있는 기능을 제공하는 패턴

   **`옵서버`**

   → 한 객체의 상태가 변화하면 객체에 상속되어 있는 다른 개체들에게 변화된 상태를 전달하는 패턴

   **`상태`**

   → 객체의 상태에 따라 동일한 동작을 다르게 처리해야 할 때 사용하는 패턴

   **`전략`**

   → 동일한 알고리즘들을 개별적으로 캡슐화하여 상호 교환할 수 있게 정의하는 패턴

   **`템플릿 메소드`**

   → 상위 클래스에서 골격을 정의하고, 하위 클래스에서 세부 처리를 구체화하는 구조의 패턴

   **`방문자`**

   → 각 클래스들의 데이터 구조에서 처리 기능을 분리하여 별도의 클래스로 구성하는 패턴
